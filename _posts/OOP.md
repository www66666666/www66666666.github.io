<font style="font-size:1.3em;font-weight:bold;"> 目录 </font> 

[toc]

# OOP

> 面向对象的编程
>
> Object Oriented Programming

----

## 1. 什么是对象

1. 世间万物皆对象
2. 客观存在的任何一个实体都是一个对象

## 2. 什么是面向过程的编程

过程的编程 注重的是步骤，任何东西 我们亲力亲为.

## 3. 什么是面向对象的编程

把一个功能个体，当作一个对象.
调用功能，得到结果，无需关心执行过程.

## 4. 为什么要使用面向对象编程

1. 提高开发效率
2. 提高项目灵活度
3. 提高项目的可扩展性


## 5. 什么是类

对相同或相似对象的一个抽象的描述.

## 6. 类与对象的关系是什么

> 先有类，才有对象.
> 通过类，得到对象，我们使用的是对象.

类中含有什么：
属性： 是什么，客观描述
方法： 干什么，行为描述

----
# OOP 语法

## 1. 类的定义

### 1.1 定义一个类

```php
[修饰符] class 类名
{
    [成员属性]
    [成员方法]
}
```

### 1.2 类的实例化(得到一个对象)

`new 类名`

### 1.3 对象成员的访问

`->` 对象成员操作符
读取或设置对象的属性
调用对象的方法

### 1.4 伪变量 `$this`

含义： 代表的是对象，表示的是自己

## 2. 成员特性

### 2.1 成员属性

- 不能重复定义
- 可以有默认值
- 默认值不能是变量
- 默认值不能有运算 （7.0+ 可以有数值运算）
- 默认值可以是常量
- 值可以是任意类型（注意是值，不是默认值）

### 2.2 成员方法

- 与函数一致
- 可以直接输出自己的成员属性


## 3. 构造方法 和 析构方法

### 3.1 构造方法

> 在得到对象的时候自动调用的方法

1. 传统的构造方法，与类名一致
2. 新的构造方法：`__construct()`

### 3.2 析构方法

> 在销毁对象的时候自动调用的方法

`__destruct()`

### 3.3 对象在内存中的存储

- 常量区: 常量，静态内容(static)
- 栈内存: 变量，局部变量
- 堆内存: 对象
- 代码区: 函数，类

## 4. 其他

### 4.1 对象的比较运算符

- `=`：对象赋值  取别名
- `==`：比较运算符  只要两个对象 是同一个类的实例,并且所有的属性及值 都相等 则相等
- `===`：比较运算符 两个对象是否是 同一个对象

### 4.2 对象的`引用传值`特性

类似于函数的引用参数，但对象无需使用`&`符号

----

# 三种对象特性

> 面向对象的三大特性：
> - `封装`
> - `继承`
> - `多态`

----

# 5. 面向对象的封装性

## 5.1 封装性的定义

> 把成员属性或成员方法，设置为非公有，被称为封装。

- `public`    公有的
- `private`   私有的
- `protected` 受保护的

## 5.2 封装性说明

- 特点
    - 非公有的方法和属性`不能`在类的外部访问
    - 只能在类的 内部的方法中,通过 $this 来访问
- 作用
    - 成员属性的封装,作用是: 实现访问控制.
    - 成员方法的封装,作用是: 提高重用性,可读性高.

# 1. 魔术方法

## 1.1 魔术方法 `__set()`

```php
public function __set($key, $value)
{
    $this->$key = $value;
}
```

- 给非公有属性 赋值时 会自动调用
- 调用时把属性名和要赋的值，作为`第1`,`第2`参数传入
- `__set()` 需要两个参数，且必须是`public`

------

## 1.2 魔术方法 `__get()`

```php
public function __get($key)
{
    return $this->$key;
}
```

- 读取非公有属性时自动触发.
- 读取时把属性的名作为参数传入.
- `__get()`方法 需要一个参数，且必须是`public`

## 1.3 魔术方法 `__isset()`

```php
public function __isset($key)
{
    return isset($this->$key);
}
```

以下情况会触发调用`__isset()` 魔术方法：

- 在类的外部，对非公有属性调用`isset()`函数时。
  - `isset()`是判断属性是否存在，不需要得到值.
- 在类的外部，对非公有属性调用`empty()`函数时。
  - 因为`empty()`判断的是 属性值是否为空，所以必须得到其值。
  - 此时添加`__get()`方法得到该属性的值，才能正确判断。

## 1.4 魔术方法 `__unset()`

```php
public function __unset($key)
{
    unset($this->$key);
}
```

当对非公有属性 调用`unset()`时，`__unset()`魔术方法会被触发调用

## 1.5 魔术方法 `__tostring()`

```php
public function __tostring()
{
    return 'string..';
}
```

- 把对象当作字符串一样，去输出的时候，自动调用该方法
- 要求该方法，必须`return`一个字串
- 可用于写类的调试信息

## 1.6 魔术方法 `__invoke()`

```php
public function __invoke()
{
    // CODE...
}
```

把对象当做函数一样，去调用时 自动触发.

作用:

1. 类似于 `__tostring()`的用法
2. 把对象当做函数一样去调用

------

# 3. 面向对象的继承性

## 3.1 定义

> 类的继承性：
> 一个子类可以继承一个父类，如果子类继承父类，子类就具有了父类的属性和方法。
> 在子类中定义：`class 子类名 extends 父类名 { }`实现继承。

继承性的作用：

1. 提高重用性
2. 方便扩展
3. 方便升级

## 3.2 访问修饰符的三种访问级别

| 访问级别 | public | private | protected |
| :------: | :----: | :-----: | :-------: |
| 类的内部 |  YES   |   YES   |    YES    |
| 类的外部 |  YES   |   NO    |    NO     |
|  子类中  |  YES   |   NO    |    YES    |

- 总结
  - 公有的，最开放的，谁的可以使用它
  - 私有的，最保守的，只有自己可以使用
  - 受保护的，只允许家族使用，外人不让用

## 3.3 继承性的三特点

1. 继承的特点之一
   - 一个子类`只能`有一个父类
   - 一个父类可以被`多个`子类继承
2. 继承的特点之二
   - 子类中`方法名`或`属性名`与父类中的`相同`，会发生属性或方法的`重写`
   - 重写只对子类有影响
3. 继承的特点之三
   - 子类可以重写父类的属性或方法时，可以修改访问控制修饰符
   - 但只能改得更开放
     - 建议重写时，一般不要修改访问级别
     - 开放顺序: `public` > `protected` > `private`

## 3.4 子类中重写父类方法的注意点

## 3.4 子类中重写父类方法的注意点

> parent::方法名()
> 在子类重写父类方法时，可以在子类中调用被覆盖的父类方法，调用的方式是 parent::方法名()



# 4. 关键字及设计模式

## 4.1 final 关键字

- 定义：可以用于修饰类和方法，不能修饰属性。
- 特点
  - final 修饰一个类，会导致该类不能被继承。
  - final 修饰一个方法，该方法不能被重写。
- 作用
  1. 提高代码安全性，保护方法和类不被重写
  2. 提高代码的可读性

------

## 4.2 static 关键字

- 定义：用于修饰属性和方法，不能修饰类
- 说明
  - 修饰的属性叫：`静态属性`，只能使用静态方式访问
  - 修饰的方法叫：`静态方法`，可以使用静态方式访问，亦可使用动态方式(不建议)
  - 静态方法中，不允许出现动态内容`$this`(非静态内容)
- 用法：
  - 在外部 访问静态属性/方法：
    - `类名::$属性名`
    - `类名::方法名()`
  - 在内部 访问静态属性/方法：
    - `self::$属性名`
    - `self::方法名()`
- 作用
  1. 类中的几个方法 没有太大的联系，可声明静态方法
  2. 实现设计模式

------

## 4.3 单例设计模式

> 定义：一个类 只能允许存在 一个对象

> 实现步骤:

# OOP  关键字及设计模式

## final 关键字

- 定义：可以用于修饰类和方法，不能修饰属性。
- 特点
  - final 修饰一个类，会导致该类不能被继承。
  - final 修饰一个方法，该方法不能被重写。
- 作用
  1. 提高代码安全性，保护方法和类不被重写
  2. 提高代码的可读性

------

## static 关键字

- 定义：用于修饰属性和方法，不能修饰类
- 说明
  - 修饰的属性叫：`静态属性`，只能使用静态方式访问
  - 修饰的方法叫：`静态方法`，可以使用静态方式访问，亦可使用动态方式(不建议)
  - 静态方法中，不允许出现动态内容`$this`(非静态内容)
- 用法：
  - 在外部 访问静态属性/方法：
    - `类名::$属性名`
    - `类名::方法名()`
  - 在内部 访问静态属性/方法：
    - `self::$属性名`
    - `self::方法名()`
- 作用
  1. 类中的几个方法 没有太大的联系，可声明静态方法
  2. 实现设计模式

------

## 单例设计模式

> 定义：一个类 只能允许存在 一个对象

> 实现步骤:

------

## 对象链

> 即 对象方法的连贯操作.
> 实现关键：`return $this`

------

## const 关键字

> 在类中使用`const`关键字来定义类常量

- 特点
  - const 只能接受`静态的标量`，不能使用变量赋值
  - define() 是函数，无法在类中定义常量
  - 在类的内部，只能使用 const 定义常量
  - 不能在函数内/循环内/if语句内，使用 const 来定义常量
- 使用
  - 在外部访问类的常量 `类名::常量名`
  - 在内部访问类的常量 `self::常量名`
- 作用
  - 配置文件，定义后，不得被更改.
  - 给函数或方法设置各种参数

> PS. `define()` 与 `const` 的区别
>
> - const 定义常量,不能有动态运算(函数等等).且必须处于最顶端,因为它是在编译时定义的.
> - define() 是一个函数,只有在被调用时才会定义常量,值为标量或null或数组,且可以有运算产生.

------

## instanceof 运算符

> 判断某个对象，是否属于`某个类`或`该类子类`的`实例`.
> 返回 `true`/`false`

------

## clone 关键字 (对象复制)

> 对象的引用赋值机制，致使要克隆才能生成新的一模一样的对象
> 语法 `$a = clone $b`

------

## 魔术方法 `__clone()`

```php
public function __clone()
{
    // CODE
}
```

- 触发条件
  - 在该对象被克隆的时候，会自动调用.
- 作用:
  1. 如果封装该魔术方法，会使该对象不能被克隆
  2. 将属性里对象值，在被克隆时，也进行克隆
  3. 当对象被克隆时,可以设置或重置 对象的属性.

------

## 魔术方法 `__call()` 和 `__callStatic()`

```php
// 魔术方法 `__call()`
public function __call($funName, $params)
{
    // CODE
}
// 魔术方法 `__callStatic()`
public static function __callStatic($funName, $params)
{
    // CODE
}
```

- 魔术方法 `__call()`
  - 当调用不存在的方法的时候自动触发
  - 参1 : 接收调用不存在方法的名字
  - 参2 : 接收调用不存在方法的参数
- 魔术方法 `__callStatic()`
  - 当调用不存在的静态方法时自动触发
  - 参1 : 接收调用不存在的静态方法的名字
  - 参2 : 接收调用不存在的静态方法的参数

------

## 自动加载类 `__autoload`

> 注意：`__autoload`是一个`函数`
>
> 当你使用一个类,而这个类不存在时,自动触发 `__autoload()`

```php
function __autoload($className)
{
    // 处理 $className
}
```

> PHP 7.0+ 请使用以下代替：
> 注册给定的函数作为 `__autoload` 的实现
> `spl_autoload_register()`
>
> `__autoload()` 方法已被废弃，   因为和  `spl_autoload_register()` 
> 相比功能较差 (因为无法链式处理多个  autoloader)，   而且也无法在两种 autoloading 样式中配合使用。 

------

## 类型约束

> 只能用来约束 参数的类型，且只能约束为 数组或对象

# 对象的串行化

> 就是将对象 转换成特定字符串

- `serialize()` 串行化,序列化
- `unserialize()` 反串行化

------

# 魔术方法 `__sleep()`

```php
public function __sleep()
{
    return array();
}
```

- 特点
  - 使用 `serialize()` 将对象串行化的时候 自动调用
  - `__sleep()` 要返回数组，数组内提供 需要保留的属性名
- 作用
  - 在对象被串行化的时候，存储需要保存下来的属性状态.
  - 清理掉不需要保存的属性数据

# 魔术方法 `__wakeup()`

```php
public function __wakeup()
{

}
```

- 特点
  - 使用`unserialize()`将字符串还原为对象时，会自动调用.
- 作用
  - 给属性赋值新值
  - 重新初始化: 重新数据库链接，重新打开资源.

------

# 总结魔术方法

```php
public function __construct(){}
public function __destruct(){}

public function __set($key, $value){$this->$key=$value}
public function __get($key){return $this->$key}

public function __isset($key){return isset($this->$key)}
public function __unset($key){return unset($this->$key)}

public function __toString(){return 'string...'}
public function __invoke(){}

public function __call($funName, $params){}
public function __callStatic($funName, $params){}

public function __sleep(){return [k1,k2]}
public function __wakeup(){}

public function __clone(){}
function __autoload($className){}
spl_autoload_register()
```

------

# 抽象方法 与 抽象类

> 抽象: 
>
> 从众多的事物中抽取出 共同的/本质性的 特征的 过程,而舍弃其非本质的特征, 就是抽象

- `抽象方法`
  - 使用关键字`abstract`来定义抽象方法
  - 抽象方法不能有方法体
- `抽象类`
  - 使用关键字`abstract`来定义抽象类.
  - 如果类中含有抽象方法，则必须把该类设为抽象类.
- 抽象类特点
  - 不能被实例化，它是用来定义标准的
- 使用
  - 使用抽象类定义的标准，要新定义一个类，并继承抽象类
  - 并且在子类中，重写抽象类里所有的抽象方法.

------

# 接口 `interface`

> 注意！ 此接口不是 `API` 应用接口： `Application Programming Interface`

- 接口 interface
  - 使用`interface`定义接口
- 特点
  1. 接口不能被实例化
  2. 接口中只允许有抽象方法和常量
  3. 抽象方法必须省略`abstract` 7.0+
  4. 接口用来定义标准。使用接口需要继承接口，重写接口中所有的方法
  5. 实现(继承)接口，不能使用`extends`，要使用 `implements`.
  6. 接口可以实现多继承
- 接口与抽象类的区别
  1. 接口中所有方法都是抽象方法，抽象类可以有普通方法
  2. 接口不能有属性，抽象类可以有属性
  3. 接口可以多继承，抽象类不可以

------

# 面向对象的多态性

> **多态性的定义**
> 子类继承父类，可以重写父类的方法和属性。
> 一个类可以有多个子类
> 不同的子类之间,就可以具有不同状态的属性值和方法体，这就是多态性。

> 不同的对象，做相同的事情，得到不同的结果

------

# PHP 异常处理

## 1. 什么是异常

- 处理逻辑错误，即可预期的错误。
- 一般指的是，正常逻辑过程中可能出现的错误。

## 2. PHP 处理异常的语法

~~~php
try {
    if (发生异常) {
        throw new Exception('msg');
    }
} catch (Exception $e) {
    // 提示异常 或 解决处理
}
````

- 特点
    - 如果抛出异常，`throw`之后的代码会终止.
    - `try`外面的代码，不受异常的影响.
    - PHP的异常需要手工抛出，其他语言 由系统 自动抛出(C++ Java...)
- 使用异常的情况
    - 程序员悲观
    - 代码健壮性要求
    - 业务逻辑需要

## 3. PHP的异常处理类

```php
// Exception是所有异常的基类。
// 以下方法来自于该基类
echo '异常信息: '.$e->getMessage().'<br>';
echo "异常号Code: ".$e->getCode()."<br>";
echo "异常所在的文件: ".$e->getFile()."<br>";
echo "异常所在的行号: ".$e->getLine()."<br>";
echo "以字串形式输入异常信息: ".$e.'<br>';
var_dump($e->getTrace()); // 显示异常的 基本信息
~~~

------

# PHP中 类与对象 相关的函数
    ```// 判断某个类 是否存在
    class_exists(className)
    
    // 获取 类或对象中 所有公有方法,返回数组
    get_class_methods(className/obj)
    
    // 获取类中 所有的公有属性,返回数组.不能获取对象的属性
    get_class_vars(className)
    
    // 获取 对象中 所有的公有属性
    get_object_vars(obj)
    
    // 返回对象的类名
    get_class(obj)
    
    // 返回对象或类的父类名
    get_parent_class(className/obj)
    
    // 判断方法是否存在
    method_exists(className/obj, 'methodname')
    
    // 判断属性是否存在
    property_exists(className/obj, 'attrname')
    
    // 判断某个对象 是否属于 某个类 或 该类子类 的实例.
    is_a(obj, 'className')
    
    // 获取所有已定义的类(包括系统定义的类)
    get_declared_classes()
    
    // PHP 保留类/所有类的基类
    stdClass()

